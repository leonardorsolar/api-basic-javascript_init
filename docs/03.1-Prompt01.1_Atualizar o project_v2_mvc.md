### Prompt 02: Crie a sua primeira proposta(proposal) de alteraÃ§Ã£o e validÃ¡-la

```bash
Atualize o arquivo openspec/project.md com as seguintes alteraÃ§Ãµes:

1. Adicione a tecnologia [TECNOLOGIA] na stack
2. Inclua a convenÃ§Ã£o de [CONVENÃ‡ÃƒO ESPECÃFICA]
3. Atualize a estrutura de pastas com [NOVA ESTRUTURA]

Mantenha as informaÃ§Ãµes existentes e adicione/modifique apenas o necessÃ¡rio.
```

Ex.:

````bash
Atualize o arquivo openspec/project.md com as seguintes alteraÃ§Ãµes:

# Estrutura de DiretÃ³rios Sugerida

```bash
projeto-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ database.js          # ConfiguraÃ§Ã£o e inicializaÃ§Ã£o do SQLite
â”‚   â”œâ”€â”€ services/                 # Classes de regra de negÃ³cio + acesso direto ao banco
â”‚   â”‚   â””â”€â”€ UserService.js
â”‚   â”œâ”€â”€ controllers/              # Classes Controller (orquestraÃ§Ã£o HTTP)
â”‚   â”‚   â””â”€â”€ UserController.js
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â””â”€â”€ errorHandler.js      # Tratamento global de erros
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ unit/                # Testes unitÃ¡rios (services)
â”‚   â”‚   â”œâ”€â”€ integration/         # Testes de integraÃ§Ã£o (controllers)
â”‚   â”‚   â””â”€â”€ setup.js
â”‚   â””â”€â”€ index.js                 # Entry point (Express + rotas + middlewares)
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

# Arquitetura MVC Simplificada (Com Classes)

**M (Model)** â†’ *nÃ£o existe model separado*
**Service (classe)** â†’ acessa diretamente o banco
**C (Controller classe)** â†’ orquestra HTTP
**View** â†’ qualquer front-end que consome JSON

ğŸŸ¢ **Sem Repositories**
ğŸŸ¢ **Sem Models**
ğŸŸ¢ **Service Ã© sempre uma Classe** (singleton)
ğŸŸ¢ **Controller Ã© sempre uma Classe** com mÃ©todos da rota

Rotas continuam sendo definidas no `index.js`.

---

# ConvenÃ§Ãµes de Nomenclatura OBRIGATÃ“RIAS

| Item               | Regra                           |
| ------------------ | ------------------------------- |
| **Classes**        | PascalCase                      |
| **Controllers**    | PascalCase + `Controller`       |
| **Services**       | PascalCase + `Service`          |
| **MÃ©todos**        | camelCase                       |
| **Constantes**     | SCREAMING_SNAKE_CASE            |
| **Tabelas SQLite** | snake_case plural               |
| **VariÃ¡veis**      | camelCase                       |
| **NÃƒO usar**       | models, repositories, callbacks |

---

# Estilo de CÃ³digo OBRIGATÃ“RIO

* ES Modules (`import` / `export`)
* Sem ponto e vÃ­rgula
* Strings com aspas duplas
* IndentaÃ§Ã£o: 4 espaÃ§os
* `async/await` sempre
* Prepared statements `?` obrigatÃ³rios
* Controllers SEMPRE com try/catch
* Services **nunca** acessam req/res
* Controllers **nunca** fazem SQL

---

# SERVICE (Classe com Regras + Banco)

**Responsabilidade:**

* ValidaÃ§Ã£o
* Regras de negÃ³cio
* Queries SQL diretas
* Erros com `statusCode`
* MÃ©todos obrigatÃ³rios:
  `getAll()`, `getById()`, `create()`, `update()`, `delete()`

```javascript
// src/services/UserService.js
import db from "../config/database.js"

class UserService {
    async getAll() {
        return db.all("SELECT * FROM users")
    }

    async getById(id) {
        this.validateId(id)

        const user = await db.get("SELECT * FROM users WHERE id = ?", [id])
        if (!user) this.throwNotFound("User not found")

        return user
    }

    async create(data) {
        this.validateUserData(data)

        const existing = await db.get(
            "SELECT * FROM users WHERE email = ?",
            [data.email]
        )
        if (existing) this.throwError("Email already registered", 409)

        const { name, email, age } = data
        const result = await db.run(
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            [name, email, age]
        )

        return { id: result.lastID, name, email, age }
    }

    async update(id, data) {
        await this.getById(id)

        if (data.email) {
            const existing = await db.get(
                "SELECT * FROM users WHERE email = ?",
                [data.email]
            )
            if (existing && existing.id !== parseInt(id)) {
                this.throwError("Email in use", 409)
            }
        }

        const { name, email, age } = data
        await db.run(
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            [name, email, age, id]
        )

        return this.getById(id)
    }

    async delete(id) {
        await this.getById(id)
        return db.run("DELETE FROM users WHERE id = ?", [id])
    }

    // MÃ©todos privados de validaÃ§Ã£o
    validateId(id) {
        if (!id || isNaN(id)) this.throwError("Invalid ID", 400)
    }

    validateUserData(data) {
        if (!data.name || data.name.trim().length < 3) {
            this.throwError("Name must be at least 3 characters", 400)
        }
        if (!data.email || !this.isValidEmail(data.email)) {
            this.throwError("Invalid email", 400)
        }
        if (!data.age || data.age < 18) {
            this.throwError("Age must be at least 18", 400)
        }
    }

    isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    }

    throwError(message, statusCode = 400) {
        const error = new Error(message)
        error.statusCode = statusCode
        throw error
    }

    throwNotFound(message) {
        this.throwError(message, 404)
    }
}

export default new UserService()
```

---

# CONTROLLER (Classe Orientada a HTTP)

**Responsabilidade:**

* Extrair dados de req
* Chamar Service
* Enviar resposta JSON
* Usar try/catch + `next(error)`
* SEM regras de negÃ³cio

```javascript
// src/controllers/UserController.js
import UserService from "../services/UserService.js"

class UserController {
    async index(req, res, next) {
        try {
            const users = await UserService.getAll()
            res.json({ success: true, data: users })
        } catch (error) {
            next(error)
        }
    }

    async show(req, res, next) {
        try {
            const user = await UserService.getById(req.params.id)
            res.json({ success: true, data: user })
        } catch (error) {
            next(error)
        }
    }

    async store(req, res, next) {
        try {
            const user = await UserService.create(req.body)
            res.status(201).json({ success: true, data: user })
        } catch (error) {
            next(error)
        }
    }

    async update(req, res, next) {
        try {
            const user = await UserService.update(req.params.id, req.body)
            res.json({ success: true, data: user })
        } catch (error) {
            next(error)
        }
    }

    async destroy(req, res, next) {
        try {
            await UserService.delete(req.params.id)
            res.status(204).send()
        } catch (error) {
            next(error)
        }
    }
}

export default new UserController()
```

---

# CONFIG DATABASE

```javascript
// src/config/database.js
import sqlite3 from "sqlite3"
import { open } from "sqlite"
import path from "path"
import { fileURLToPath } from "url"

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const DB_PATH = process.env.DB_PATH || path.join(__dirname, "../../database.sqlite")

let db = null

async function getDatabase() {
    if (db) return db

    db = await open({
        filename: DB_PATH,
        driver: sqlite3.Database
    })

    await db.exec("PRAGMA foreign_keys = ON")
    return db
}

export default await getDatabase()
```

---

# MIDDLEWARE DE ERRO

```javascript
// src/middlewares/errorHandler.js
export default (err, req, res, next) => {
    console.error("Error:", err.stack)

    res.status(err.statusCode || 500).json({
        success: false,
        message: err.message || "Internal Server Error",
        ...(process.env.NODE_ENV === "development" && { stack: err.stack })
    })
}
```

---

# INDEX + ROTAS REST

```javascript
// src/index.js
import express from "express"
import UserController from "./controllers/UserController.js"
import errorHandler from "./middlewares/errorHandler.js"

const app = express()
const PORT = process.env.PORT || 3000

app.use(express.json())

app.get("/api/users", UserController.index)
app.get("/api/users/:id", UserController.show)
app.post("/api/users", UserController.store)
app.put("/api/users/:id", UserController.update)
app.delete("/api/users/:id", UserController.destroy)

app.use(errorHandler)

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`)
})

export default app
```

---

# PadrÃµes de Resposta JSON

Sucesso:

```json
{ "success": true, "data": {...} }
```

Erro:

```json
{ "success": false, "message": "DescriÃ§Ã£o do erro" }
```

---

# REGRAS INVIOLÃVEIS

1. SQL **somente** nos Services
2. Controllers SEMPRE try/catch
3. Erros levam statusCode
4. NUNCA usar callbacks
5. NUNCA expor stack em produÃ§Ã£o
6. SEMPRE validar dados
7. JSON sempre `{ success: boolean }`
8. Rotas ficam no index.js
9. Service Ã© classe + singleton
10. Controllers usam mÃ©todos de classe

---

# Checklist de ImplementaÃ§Ã£o

* [ ] Service: classe + SQL + validaÃ§Ãµes
* [ ] Controller: classe + try/catch
* [ ] Rotas definidas no index.js
* [ ] Middleware de erro por Ãºltimo
* [ ] Singleton em Services e Controllers
* [ ] Prepared statements `?`
* [ ] Respostas padronizadas
* [ ] Testes unitÃ¡rios (services)
* [ ] Testes de integraÃ§Ã£o (controllers)

````

Depois que a IA criar/atualizar o arquivo, vocÃª revisa e pede ajustes:

```bash
Revise o openspec/project.md e ajuste:
- Adicione mais detalhes sobre [ASPECTO ESPECÃFICO]
- Corrija a descriÃ§Ã£o de [ITEM]
- Remova [INFORMAÃ‡ÃƒO DESNECESSÃRIA]
```

**Valide:** Ã© importante vocÃª validar para seguir para o prÃ³ximo passo.

```bash
openspec validate [change-id] --strict
```

Ex.:

```bash
openspec validate [add-user-registration] --strict
```
