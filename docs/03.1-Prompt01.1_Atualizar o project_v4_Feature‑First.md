### Prompt 02: Crie a sua primeira proposta(proposal) de alteraÃ§Ã£o e validÃ¡-la

```bash
Atualize o arquivo openspec/project.md com as seguintes alteraÃ§Ãµes:

1. Adicione a tecnologia [TECNOLOGIA] na stack
2. Inclua a convenÃ§Ã£o de [CONVENÃ‡ÃƒO ESPECÃFICA]
3. Atualize a estrutura de pastas com [NOVA ESTRUTURA]

Mantenha as informaÃ§Ãµes existentes e adicione/modifique apenas o necessÃ¡rio.
```

```bash
Atualize o arquivo `openspec/project.md` com as seguintes alteraÃ§Ãµes:

1. Adicione a tecnologia **[TECNOLOGIA]** na stack.
2. Inclua a convenÃ§Ã£o **[CONVENÃ‡ÃƒO ESPECÃFICA]**.
3. Atualize a estrutura de pastas para o padrÃ£o **Feature-First (Vertical Slice)** conforme abaixo.

Mantenha todas as informaÃ§Ãµes existentes e altere apenas o necessÃ¡rio
```

Ex.:

`````bash

Atualize o arquivo `openspec/project.md` com as seguintes alteraÃ§Ãµes:

1. Adicione a tecnologia **[TECNOLOGIA]** na stack.
2. Inclua a convenÃ§Ã£o **[CONVENÃ‡ÃƒO ESPECÃFICA]**.
3. Atualize a estrutura de pastas para o padrÃ£o **Feature-First (Vertical Slice)** conforme abaixo.

Mantenha todas as informaÃ§Ãµes existentes e altere apenas o necessÃ¡rio.

---

# ğŸ—‚ï¸ Estrutura de DiretÃ³rios â€” Feature-First (Vertical Slice)

```bash
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserController.js
â”‚   â”‚   â”‚   â””â”€â”€ userRoutes.js
â”‚   â”‚   â”œâ”€â”€ app/               # Casos de uso (Use Cases)
â”‚   â”‚   â”‚   â””â”€â”€ CreateUserUseCase.js
â”‚   â”‚   â”œâ”€â”€ domain/            # Entidades, regras de domÃ­nio e validaÃ§Ãµes
â”‚   â”‚   â”‚   â””â”€â”€ User.js
â”‚   â”‚   â”œâ”€â”€ infra/             # RepositÃ³rios, gateways, providers
â”‚   â”‚   â”‚   â””â”€â”€ SqliteUserRepository.js
â”‚   â”‚   â””â”€â”€ tests/             # Testes da feature
â”‚   â””â”€â”€ auth/
â”‚       â”œâ”€â”€ http/
â”‚       â”œâ”€â”€ app/
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ infra/
â”‚       â””â”€â”€ tests/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ http/middlewares/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ config/
â””â”€â”€ index.js
````

---

# ğŸ“ ConvenÃ§Ãµes de Nomenclatura OBRIGATÃ“RIAS (Feature-First)

**Features:** `kebab-case`
* Ex.: `user-profile`, `reset-password`
**Use Cases:** `PascalCase` + `UseCase`
* Ex.: `CreateUserUseCase.js`
**Controllers:** `PascalCase` + `Controller`
**Routes:** `camelCase` + `Routes`
**Entidades de domÃ­nio:** `PascalCase`
**RepositÃ³rios:** `PascalCase` + `Repository`
**VariÃ¡veis:** `camelCase`
**Constantes:** `SCREAMING_SNAKE_CASE`

---

# ğŸ§  PadrÃµes ArquitetÃ´nicos â€” Vertical Slice

Cada **feature** Ã© totalmente isolada e contÃ©m **todas as camadas** necessÃ¡rias.

## ### 1. HTTP Layer (Controller + Routes)

**Local:** `features/<feature>/http/`
**Componentes:**

* Controllers
* Rotas
* Middlewares especÃ­ficos da feature

**Regras:**

* NÃ£o contÃ©m lÃ³gica de negÃ³cio
* NÃ£o acessa banco
* Apenas chama Use Cases
* Sempre usar try/catch
* Sempre usar `next(error)`
* Respostas padrÃ£o `{ success, data }`

/src/features/users/http/UserController.js
```javascript
import CreateUserUseCase from "../app/CreateUserUseCase.js"

class UserController {
    async index(req, res, next) {
        try {
            const users = await CreateUserUseCase.listAll()
            res.json({ success: true, data: users })
        } catch (err) {
            next(err)
        }
    }

    async show(req, res, next) {
        try {
            const user = await CreateUserUseCase.getById(req.params.id)
            res.json({ success: true, data: user })
        } catch (err) {
            next(err)
        }
    }

    async store(req, res, next) {
        try {
            const created = await CreateUserUseCase.execute(req.body)
            res.status(201).json({ success: true, data: created })
        } catch (err) {
            next(err)
        }
    }

    async update(req, res, next) {
        try {
            const updated = await CreateUserUseCase.update(req.params.id, req.body)
            res.json({ success: true, data: updated })
        } catch (err) {
            next(err)
        }
    }

    async destroy(req, res, next) {
        try {
            await CreateUserUseCase.remove(req.params.id)
            res.status(204).send()
        } catch (err) {
            next(err)
        }
    }
}

export default new UserController()

/src/features/users/http/userRoutes.js

import { Router } from "express"
import UserController from "./UserController.js"

const router = Router()

router.get("/users", (req, res, next) => UserController.index(req, res, next))
router.get("/users/:id", (req, res, next) => UserController.show(req, res, next))
router.post("/users", (req, res, next) => UserController.store(req, res, next))
router.put("/users/:id", (req, res, next) => UserController.update(req, res, next))
router.delete("/users/:id", (req, res, next) => UserController.destroy(req, res, next))

export default router


---

## ### 2. App Layer (Use Cases)

**Local:** `features/<feature>/app/`
**Componentes:**

* Arquivos de caso de uso
* OrquestraÃ§Ãµes da lÃ³gica da feature

**Regras:**

* ContÃ©m TODA a lÃ³gica da feature
* Pode chamar mÃºltiplos repositÃ³rios
* NÃ£o conhece HTTP
* NÃ£o conhece Express
* NÃ£o contÃ©m SQL
* Pode validar regras de negÃ³cio

/src/features/users/app/CreateUserUseCase.js

import UserRepository from "../infra/SqliteUserRepository.js"
import User from "../domain/User.js"

class CreateUserUseCase {
    async execute(data) {
        // ValidaÃ§Ã£o de dados de entrada (delegada parcialmente ao Domain)
        const userEntity = new User(data)
        userEntity.validate()

        // Regras de negÃ³cio: por exemplo, checar duplicidade
        const exists = await UserRepository.findByEmail(userEntity.email)
        if (exists) {
            const err = new Error("Email already registered")
            err.statusCode = 409
            throw err
        }

        const created = await UserRepository.create(userEntity.toJSON())
        return created
    }

    async listAll() {
        return UserRepository.findAll()
    }

    async getById(id) {
        const user = await UserRepository.findById(id)
        if (!user) {
            const err = new Error("User not found")
            err.statusCode = 404
            throw err
        }
        return user
    }

    async update(id, data) {
        // validar id + dados (poderia usar User as validator)
        await this.getById(id)
        return UserRepository.update(id, data)
    }

    async remove(id) {
        await this.getById(id)
        return UserRepository.delete(id)
    }
}

export default new CreateUserUseCase()


---

## ### 3. Domain Layer

**Local:** `features/<feature>/domain/`
**Componentes:**

* Entidades
* Value Objects
* Regras de domÃ­nio puras
* ValidaÃ§Ãµes independentes

**Regras:**

* Zero dependÃªncias externas
* Nunca importa `infra`
* Nunca importa `http`
* NÃ£o usa Express
* NÃ£o usa SQLite

/src/features/users/domain/User.js

export default class User {
    constructor({ id = null, name, email, age } = {}) {
        this.id = id
        this.name = name
        this.email = email
        this.age = age
    }

    validate() {
        if (!this.name || this.name.trim().length < 3) {
            const err = new Error("Name must be at least 3 characters")
            err.statusCode = 400
            throw err
        }

        if (!this.email || !this.constructor.isValidEmail(this.email)) {
            const err = new Error("Invalid email")
            err.statusCode = 400
            throw err
        }

        if (!this.age || Number(this.age) < 18) {
            const err = new Error("Age must be at least 18")
            err.statusCode = 400
            throw err
        }
    }

    static isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    }

    toJSON() {
        return { id: this.id, name: this.name, email: this.email, age: this.age }
    }
}

---

## ### 4. Infra Layer

**Local:** `features/<feature>/infra/`
**Componentes:**

* RepositÃ³rios (ex.: SQLite, PostgreSQL)
* Gateways
* Providers
* Adapters externos

**Regras:**

* **Somente implementaÃ§Ã£o concreta**
* SQL permitido apenas aqui
* Permite chamadas a APIs externas
* NÃ£o contÃ©m regra de negÃ³cio
* Interface clara para Use Cases

/src/features/users/infra/SqliteUserRepository.js

import db from "../../../../shared/config/database.js" // caminho de exemplo

class SqliteUserRepository {
    async findAll() {
        return db.all("SELECT id, name, email, age FROM users")
    }

    async findById(id) {
        return db.get("SELECT id, name, email, age FROM users WHERE id = ?", [id])
    }

    async findByEmail(email) {
        return db.get("SELECT id, name, email, age FROM users WHERE email = ?", [email])
    }

    async create(data) {
        const { name, email, age } = data
        const result = await db.run(
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            [name, email, age]
        )
        return { id: result.lastID, name, email, age }
    }

    async update(id, data) {
        const { name, email, age } = data
        await db.run(
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            [name, email, age, id]
        )
        return this.findById(id)
    }

    async delete(id) {
        return db.run("DELETE FROM users WHERE id = ?", [id])
    }
}

export default new SqliteUserRepository()

Shared / Config â€” Database singleton (exemplo)

/src/shared/config/database.js

import sqlite3 from "sqlite3"
import { open } from "sqlite"
import path from "path"
import { fileURLToPath } from "url"

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const DB_PATH = process.env.DB_PATH || path.join(__dirname, "../../../database.sqlite")

let db = null

async function getDatabase() {
    if (db) return db

    db = await open({
        filename: DB_PATH,
        driver: sqlite3.Database
    })

    await db.exec("PRAGMA foreign_keys = ON")
    return db
}

export default await getDatabase()

Shared Middleware â€” Error Handler (exemplo)

/src/shared/http/middlewares/errorHandler.js

export default function errorHandler(err, req, res, next) {
    console.error(err.stack)
    res.status(err.statusCode || 500).json({
        success: false,
        message: err.message || "Internal Server Error",
        ...(process.env.NODE_ENV === "development" && { stack: err.stack })
    })
}

7) Index (entry point) â€” montar rotas das features
/src/index.js

import express from "express"
import userRoutes from "./features/users/http/userRoutes.js"
import errorHandler from "./shared/http/middlewares/errorHandler.js"

const app = express()
const PORT = process.env.PORT || 3000

app.use(express.json())

// prefixo da API (ex.: /api)
app.use("/api", userRoutes)

// outros mounts: app.use("/api/auth", authRoutes) etc.

// middleware final de erro
app.use(errorHandler)

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`)
})

export default app


---

## ### 5. Tests Layer

**Local:** `features/<feature>/tests/`
**ContÃ©m:**

* Testes de Use Cases
* Testes de Controller
* Mocks de repositÃ³rios
* Testes unitÃ¡rios e de integraÃ§Ã£o

8) Testes â€” exemplos unitÃ¡rio e de integraÃ§Ã£o
/src/features/users/tests/unit/CreateUserUseCase.test.js
import CreateUserUseCase from "../../app/CreateUserUseCase.js"
import UserRepository from "../../infra/SqliteUserRepository.js"

jest.mock("../../infra/SqliteUserRepository.js")

test("should throw error for short name", async () => {
    await expect(
        CreateUserUseCase.execute({ name: "Jo", email: "jo@test.com", age: 25 })
    ).rejects.toThrow("Name must be at least 3 characters")
})
/src/features/users/tests/integration/userController.test.js

import request from "supertest"
import app from "../../../../index.js"
import db from "../../../../shared/config/database.js"

beforeAll(async () => {
    // opcional: preparar DB (migrations / seed)
})

afterAll(async () => {
    // opcional: fechar DB
    await db.close()
})

test("POST /api/users - should create user", async () => {
    const res = await request(app)
        .post("/api/users")
        .send({ name: "JoÃ£o", email: "joao@test.com", age: 25 })

    expect(res.status).toBe(201)
    expect(res.body.success).toBe(true)
    expect(res.body.data).toHaveProperty("id")
})



---

# ğŸ”€ Fluxo ObrigatÃ³rio no Vertical Slice

```
Request â†’ Route â†’ Controller â†’ UseCase â†’ Repository â†’ Banco/API â†’ UseCase â†’ Controller â†’ Response
```

---

# ğŸ“¦ Pasta Shared (CÃ³digo Global)

**Local:** `src/shared/`

ContÃ©m apenas cÃ³digo reutilizÃ¡vel e livre de lÃ³gica de feature:

* `middlewares/`
* `config/`
* `utils/`
* `errors/` (opcional)

---

# ğŸ“‘ PadrÃ£o de Respostas HTTP

## Sucesso:

```json
{ "success": true, "data": {} }
```

## Lista:

```json
{ "success": true, "data": [] }
```

## Erro:

```json
{ "success": false, "message": "Erro detalhado" }
```

---

# âœ”ï¸ Checklist do PadrÃ£o Feature-First

* [ ] Cada feature tem suas prÃ³prias pastas
* [ ] DomÃ­nio isolado
* [ ] Infra isolada
* [ ] Sem cross-import entre features
* [ ] Regras de negÃ³cio apenas nos Use Cases
* [ ] Controllers sem lÃ³gica
* [ ] Somente `infra` acessa banco
* [ ] Respostas padronizadas
* [ ] Nomes seguindo convenÃ§Ãµes
* [ ] Testes dentro da feature

---

```

Depois que a IA criar/atualizar o arquivo, vocÃª revisa e pede ajustes:

```bash
Revise o openspec/project.md e ajuste:
- Adicione mais detalhes sobre [ASPECTO ESPECÃFICO]
- Corrija a descriÃ§Ã£o de [ITEM]
- Remova [INFORMAÃ‡ÃƒO DESNECESSÃRIA]
```

**Valide:** Ã© importante vocÃª validar para seguir para o prÃ³ximo passo.

```bash
openspec validate [change-id] --strict
```

Ex.:

```bash
openspec validate [add-user-registration] --strict
```
`````
