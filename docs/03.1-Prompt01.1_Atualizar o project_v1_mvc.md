### Prompt 02: Crie a sua primeira proposta(proposal) de alteração e validá-la

```bash
Atualize o arquivo openspec/project.md com as seguintes alterações:

1. Adicione a tecnologia [TECNOLOGIA] na stack
2. Inclua a convenção de [CONVENÇÃO ESPECÍFICA]
3. Atualize a estrutura de pastas com [NOVA ESTRUTURA]

Mantenha as informações existentes e adicione/modifique apenas o necessário.
```

Ex.:

`````bash
Atualize o arquivo openspec/project.md com as seguintes alterações:

# Estrutura de Diretórios Sugerida:

````bash
projeto-api/
├── src/
│   ├── config/
│   │   └── database.js          # Configuração e inicialização do SQLite
│   ├── services/                 # Lógica de negócio, validações E acesso ao banco
│   │   └── UserService.js
│   ├── controllers/              # Orquestração request → service → response
│   │   └── UserController.js
│   ├── middlewares/
│   │   └── errorHandler.js      # Tratamento global de erros
│   ├── tests/
│   │   ├── unit/                # Testes unitários (services)
│   │   ├── integration/         # Testes de integração (controllers)
│   │   └── setup.js
│   └── index.js                 # Entry point (Express + rotas + middlewares)
├── .env
├── .gitignore
├── package.json
└── README.md

## Arquitetura MVC Simplificada para API REST

**M (Model)** → **Service acessa diretamente o banco** - sem camada separada
**V (View)** → Front-end React consumindo JSON (separado do back-end)
**C (Controller)** → `/controllers/` - Orquestra requisições HTTP e respostas

## Diferença para MVC Tradicional

**Sem repositories** - Service faz queries SQL diretamente
**Sem models** - Dados são objetos JavaScript simples
**Sem camada routes** - Rotas definidas no index.js
**Service centraliza** - Validações + Regras + SQL tudo em um lugar

## Convenções de Nomenclatura OBRIGATÓRIAS

- **Controllers**: `PascalCase` + sufixo Controller (ex.: `UserController.js`)
- **Classes**: `PascalCase`
- **Métodos**: `camelCase`
- **Constantes**: `SCREAMING_SNAKE_CASE` (ex.: `DB_PATH`, `PORT`)
- **Tabelas SQLite**: `snake_case` plural (ex.: `users`, `product_categories`)
- **Variáveis**: `camelCase` (ex.: `userData`, `totalCount`)
- Sem models
- Sem repositories
- Sem camadas extras
- Rotas ficam no index.js
- Services acessam diretamente o banco

## Estilo de Código OBRIGATÓRIO

- ES Modules: usar `import`/`export`
- SEM ponto-e-vírgula no final das linhas
- Aspas duplas para strings
- Indentação: 4 espaços
- Async/await para operações assíncronas (NUNCA callbacks)
- Prepared statements (?) para queries SQL
- Try-catch em todos os métodos de Controller

## Padrões Arquitetônicos

### SERVICE (Camada de Negócio + Dados)
**Responsabilidade:** Lógica de negócio, validações E queries SQL diretas ao banco
**O Service substitui Repository + Model - tudo em um lugar**
**Regras:**
- Fazer queries SQL diretamente com prepared statements (?)
- Aplicar todas as validações de negócio
- Implementar regras de negócio complexas
- Lançar erros com statusCode quando apropriado
- NUNCA manipular req/res diretamente
- Retornar dados processados ou lançar Error
```javascript
// src/services/UserService.js
import db from "../config/database.js"

class UserService {
    async getAll() {
        return db.all("SELECT * FROM users")
    }

    async getById(id) {
        this.validateId(id)

        const user = await db.get("SELECT * FROM users WHERE id = ?", [id])
        if (!user) this.throwNotFound("User not found")

        return user
    }

    async create(data) {
        this.validateUserData(data)

        const existing = await db.get(
            "SELECT * FROM users WHERE email = ?",
            [data.email]
        )
        if (existing) this.throwError("Email already registered", 409)

        const { name, email, age } = data
        const result = await db.run(
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            [name, email, age]
        )

        return { id: result.lastID, name, email, age }
    }

    async update(id, data) {
        await this.getById(id)

        if (data.email) {
            const existing = await db.get(
                "SELECT * FROM users WHERE email = ?",
                [data.email]
            )
            if (existing && existing.id !== parseInt(id)) {
                this.throwError("Email in use", 409)
            }
        }

        const { name, email, age } = data
        await db.run(
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            [name, email, age, id]
        )

        return this.getById(id)
    }

    async delete(id) {
        await this.getById(id)
        return db.run("DELETE FROM users WHERE id = ?", [id])
    }

    // Validações privadas
    validateId(id) {
        if (!id || isNaN(id)) this.throwError("Invalid ID", 400)
    }

    validateUserData(data) {
        if (!data.name || data.name.trim().length < 3) {
            this.throwError("Name must be at least 3 characters", 400)
        }
        if (!data.email || !this.isValidEmail(data.email)) {
            this.throwError("Invalid email", 400)
        }
        if (!data.age || data.age < 18) {
            this.throwError("Age must be at least 18", 400)
        }
    }

    isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    }

    throwError(message, statusCode = 400) {
        const error = new Error(message)
        error.statusCode = statusCode
        throw error
    }

    throwNotFound(message) {
        this.throwError(message, 404)
    }
}

export default new UserService()
```

### CONTROLLER (Orquestração HTTP)
**Responsabilidade:** Receber requisição, chamar Service, retornar resposta HTTP
**Regras:**
- Sempre usar try-catch
- Passar erros para middleware com `next(error)`
- Extrair dados de req.body, req.params, req.query
- Retornar status HTTP apropriados
- Métodos padrão: `index`, `show`, `store`, `update`, `destroy`
- NUNCA incluir lógica de negócio ou SQL
```javascript
// src/controllers/UserController.js
import UserService from "../services/UserService.js"

export const index = async (req, res, next) => {
    try {
        const users = await UserService.getAll()
        res.json({ success: true, data: users })
    } catch (error) {
        next(error)
    }
}

export const show = async (req, res, next) => {
    try {
        const user = await UserService.getById(req.params.id)
        res.json({ success: true, data: user })
    } catch (error) {
        next(error)
    }
}

export const store = async (req, res, next) => {
    try {
        const user = await UserService.create(req.body)
        res.status(201).json({ success: true, data: user })
    } catch (error) {
        next(error)
    }
}

export const update = async (req, res, next) => {
    try {
        const user = await UserService.update(req.params.id, req.body)
        res.json({ success: true, data: user })
    } catch (error) {
        next(error)
    }
}

export const destroy = async (req, res, next) => {
    try {
        await UserService.delete(req.params.id)
        res.status(204).send()
    } catch (error) {
        next(error)
    }
}
```

### DATABASE CONFIG
```javascript
// src/config/database.js
import sqlite3 from "sqlite3"
import { open } from "sqlite"
import path from "path"
import { fileURLToPath } from "url"

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const DB_PATH = process.env.DB_PATH || path.join(__dirname, "../../database.sqlite")

let db = null

async function getDatabase() {
    if (db) return db

    db = await open({
        filename: DB_PATH,
        driver: sqlite3.Database
    })

    await db.exec("PRAGMA foreign_keys = ON")
    return db
}

export default await getDatabase()
```

### ERROR HANDLER
```javascript
// src/middlewares/errorHandler.js
export default (err, req, res, next) => {
    console.error("Error:", err.stack)

    res.status(err.statusCode || 500).json({
        success: false,
        message: err.message || "Internal Server Error",
        ...(process.env.NODE_ENV === "development" && { stack: err.stack })
    })
}
```

### INDEX (Entry Point + Rotas)
```javascript
// src/index.js
import express from "express"
import * as UserController from "./controllers/UserController.js"
import errorHandler from "./middlewares/errorHandler.js"

const app = express()
const PORT = process.env.PORT || 3000

// Middlewares globais
app.use(express.json())

// Rotas - definidas diretamente no index.js
app.get("/api/users", UserController.index)
app.get("/api/users/:id", UserController.show)
app.post("/api/users", UserController.store)
app.put("/api/users/:id", UserController.update)
app.delete("/api/users/:id", UserController.destroy)

// Middleware de erro (sempre por último)
app.use(errorHandler)

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`)
})

export default app
```

## Regras de Ouro

### Service
✅ Queries SQL diretas com prepared statements (?)
✅ Validações de dados
✅ Regras de negócio
✅ Lançar erros com `statusCode`
✅ Métodos: `getAll()`, `getById()`, `create()`, `update()`, `delete()`
❌ Manipular req/res

### Controller
✅ Extrair dados de `req`
✅ Chamar Services
✅ Try-catch + `next(error)`
✅ Retornar respostas JSON com status HTTP correto
❌ Lógica de negócio
❌ Validações
❌ Queries SQL

### Index.js
✅ Configurar Express
✅ Definir rotas RESTful
✅ Aplicar middlewares globais
✅ Middleware de erro por último
❌ Lógica de negócio

## Padrões de Resposta HTTP OBRIGATÓRIOS

**Sucesso:**
```javascript
{ success: true, data: {...} }
{ success: true, data: [...] }
```

**Erro:**
```javascript
{ success: false, message: "Descrição clara do erro" }
```

**Lista paginada:**
```javascript
{
    success: true,
    data: [...],
    pagination: { page: 1, limit: 10, total: 100 }
}
```

**Status Codes:**
- 200: GET sucesso
- 201: POST sucesso (criação)
- 204: DELETE sucesso (sem conteúdo)
- 400: Bad Request (validação falhou)
- 404: Not Found
- 409: Conflict (recurso duplicado)
- 500: Internal Server Error

## REGRAS INVIOLÁVEIS

1. **NUNCA fazer queries SQL em Controllers ou index.js**
2. **SEMPRE usar prepared statements (?) para prevenir SQL injection**
3. **SEMPRE usar try-catch em métodos de Controller**
4. **SEMPRE passar erros para middleware com next(error)**
5. **NUNCA usar callbacks, sempre async/await**
6. **NUNCA expor stack traces em produção**
7. **SEMPRE validar entrada do usuário antes de processar**
8. **SEMPRE retornar objetos com { success: boolean }**
9. **Service faz SQL + validações + regras em um só lugar**
10. **Controllers devem ter no máximo 50 linhas por método**


`````

## Checklist de Implementação

-   [ ] Service: queries SQL + validações + lógica
-   [ ] Controller: try-catch + next(error)
-   [ ] index.js: rotas RESTful + middlewares
-   [ ] Sempre usar prepared statements (?)
-   [ ] Erros com statusCode
-   [ ] Respostas com { success: boolean }
-   [ ] Classes exportadas como singleton (`export default new Class()`)
-   [ ] Controllers com named exports
-   [ ] Testes unitários para Services
-   [ ] Testes de integração para Controllers
-   [ ] Middleware de erro sempre por último no index.js

````


Depois que a IA criar/atualizar o arquivo, você revisa e pede ajustes:

```bash
Revise o openspec/project.md e ajuste:
- Adicione mais detalhes sobre [ASPECTO ESPECÍFICO]
- Corrija a descrição de [ITEM]
- Remova [INFORMAÇÃO DESNECESSÁRIA]
```

**Valide:** é importante você validar para seguir para o próximo passo.

```bash
openspec validate [change-id] --strict
```

Ex.:

```bash
openspec validate [add-user-registration] --strict
```
````
